require 'open3'
require 'io/wait'

##
# Class holding various helper functions as class methods.
#
# @attr [TrueClass, FalseClass] :external_command_silent Set to true hide output generated by processes
#   run by @see run_external_command
class Utilities

  ##
  # Global random instance
  # Instances with specific seeds can be stored here with the @see Utilities::srand, and
  # accessed with @see Utilities::random
  @@random = Random

  class << self
    attr_accessor :external_command_silent
  end

  def self.multiple_file_open(filenames, perm, &block)
    files = filenames.collect { |fn| File.open fn, perm }

    block.call files

    files.each { |file| file.close unless file.closed? }
  end

  def self.deep_copy(obj)
    # simple deep copy that works for our test fixtures
    return Marshal.load(Marshal.dump(obj))
  end

  ##
  # Runs an external shell command.
  #
  # @note Stderr output is written to STDERR. Stdout output is written to STDOUT if no stdout_file
  #   argument is given.
  #
  # @param cmd [String] The shell command string. Should not include pipes.
  # @param stdin_file [IO, NilClass] IO instance to read input to the shell process from.
  # @param stdout_file [IO, NilClass] IO instance to write shell process output to.
  # @return [Process::Status] Shell command exit status.
  def self.run_shell_command(cmd, stdin_file=nil, stdout_file=nil)
    if stdin_file
      stdin, stdout, stderr, thr = Open3.popen3 cmd

      oe = ""
      err = ""

      # read and write stdin/stdout/stderr to avoid deadlocking on processes that blocks on writing.
      # e.g. HunPos
      while true

        # wait until stdout is emptied until we try to write or hunpos-tag will block
        while not stdout.ready?
          stdin.puts(stdin_file.readline)

          # break completely out if there is no more inout
          break if stdin_file.eof?
        end

        break if stdin_file.eof?

        while stdout.ready?
          if stdout_file
            stdout_file.write(stdout.readline)
          else
            oe += stdout.readline
          end
        end

        while stderr.ready?
          err += stderr.readline
        end
      end

      stdin.close

      # get the rest of the output
      if stdout_file
        stdout_file.write(stdout.read)
      else
        oe += stdout.read
      end

      stdout.close

      err += stderr.read
      stderr.close

      # wait and get get Process::Status
      s = thr.value
    else
      out, err, s = Open3.capture3(cmd)
    end

    # echo errors on STDERR
    STDERR.puts(err) if not self.external_command_silent

    # echo command output
    if stdout_file.nil?
      puts(oe) if not self.external_command_silent
    else
      puts(out) if not self.external_command_silent
    end

    return s
  end

  def self.get_script_path
    path = File.dirname __FILE__

    return path
  end

  ##
  # Stores Random instance with the given seed, or a random seed if nil is passed
  # @param seed [Integer, NilClass]
  # @return [Random]
  def self.srand(seed=nil)
    if seed.nil?
      @@random = Random
    else
      @@random = Random.new(seed)
    end
  end

  ##
  # Accessor for the global Random instance
  # @return [Random]
  def self.random
    @@random
  end

  ##
  # @param arr [Array] Array of instances implementing to_f()
  # @return [Float] The mean/average of numbers in the array.
  def self.mean(arr)
    arr.inject { |acc, x| acc + x.to_f } / arr.count
  end
end
