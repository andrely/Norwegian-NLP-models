require 'open3'
require 'io/wait'

require 'textlabnlp/globals'

##
# Class holding various helper functions as class methods.
#
# @attr [TrueClass, FalseClass] :external_command_silent Set to true hide output generated by processes
#   run by @see run_external_command
class Utilities

  ##
  # Global random instance
  # Instances with specific seeds can be stored here with the @see Utilities::srand, and
  # accessed with @see Utilities::random
  #noinspection RubyClassVariableUsageInspection
  @@random = Random

  class << self
    attr_accessor :external_command_silent
  end

  def self.multiple_file_open(filenames, perm, &block)
    files = filenames.collect { |fn| File.open fn, perm }

    result = block.call files

    files.each { |file| file.close unless file.closed? }

    result
  end

  def self.deep_copy(obj)
    # simple deep copy that works for our test fixtures
    #noinspection RubyResolve
    return Marshal.load(Marshal.dump(obj))
  end

  def self.get_script_path
    path = File.dirname __FILE__

    return path
  end

  ##
  # Stores Random instance with the given seed, or a random seed if nil is passed
  # @param seed [Integer, NilClass]
  # @return [Random]
  def self.srand(seed=nil)
    if seed.nil?
      #noinspection RubyClassVariableUsageInspection
      @@random = Random
    else
      #noinspection RubyClassVariableUsageInspection
      @@random = Random.new(seed)
    end
  end

  ##
  # Accessor for the global Random instance
  # @return [Random]
  #noinspection RubyClassVariableUsageInspection
  def self.random
    @@random
  end

  ##
  # @param arr [Array] Array of instances implementing to_f()
  # @return [Float] The mean/average of numbers in the array.
  def self.mean(arr)
    arr.inject { |acc, x| acc + x.to_f } / arr.count
  end

  def self.stddev(arr)
    mean = self.mean(arr)
    arr.inject { |acc, x| acc + (x.to_f - mean)**2 } / arr.count
  end

  ##
  # Runs the command string and returns the output if successful. Otherwise returns false
  # @param cmd [String] Shell command string
  # @return [String, FalseClass]
  def self.runnable?(cmd)
    begin
      out = StringIO.new
      TextlabNLP.run_shell_command(cmd, stdout_file: out)

      return out.string
    rescue Errno::ENOENT
      return false
    end
  end
end
